// AUTOGENERATED FILE. Do not modify this file manually, it will be overwritten.
// finlang v0.3.0-alpha generated this file for C# `hal.SpiMasterBitBang` type.
// Source file: `LedBlinker/hal/shift/SpiMasterBitBang.cs` (relative to C# solution).
// MD5 hash of source file: d69e0fbc2bbf1e09cdd1f75d54a5ead5.


#include "hal_SpiMasterBitBang.h"
#include <string.h>



void hal_SpiMasterBitBang_ctor(hal_SpiMasterBitBang * self, hal_IDigOut * clock, hal_IDigOut * mosi, hal_IDigIn * miso, hal_IDelayObj * delay_obj)
{
    memset(self, 0, sizeof(*self));
    self->_clock = clock;
    self->_mosi = mosi;
    self->_miso = miso;
    self->_delay_obj = delay_obj;
}

void hal_SpiMasterBitBang_rx_array(hal_SpiMasterBitBang * self, uint8_t * data, uint8_t data_length)
{
}

uint8_t hal_SpiMasterBitBang_rx_byte(hal_SpiMasterBitBang * self)
{
    return 0;
}

void hal_SpiMasterBitBang_rx_tx_array(hal_SpiMasterBitBang * self, uint8_t * tx_data, uint8_t * rx_data, uint8_t data_length)
{
}

void PRIVATE_hal_SpiMasterBitBang__delay(hal_SpiMasterBitBang * self)
{
    hal_IDelayObj_delay(self->_delay_obj);
}

void PRIVATE_hal_SpiMasterBitBang__clock_high(hal_SpiMasterBitBang * self)
{
    hal_IDigOut_set_output_state(self->_clock, true);
}

void PRIVATE_hal_SpiMasterBitBang__clock_low(hal_SpiMasterBitBang * self)
{
    hal_IDigOut_set_output_state(self->_clock, false);
}

uint8_t hal_SpiMasterBitBang_rx_tx_byte(hal_SpiMasterBitBang * self, uint8_t tx_byte)
{
    uint8_t read_byte = 0;
    PRIVATE_hal_SpiMasterBitBang__clock_low(self); // just to make sure

    for (uint8_t i = 0; i < 8; i++)
    {
        hal_SpiMasterBitBang_rx_tx_bit_lsb(self, &tx_byte, &read_byte);
    }

    return read_byte;
}

void hal_SpiMasterBitBang_rx_tx_bit_lsb(hal_SpiMasterBitBang * self, uint8_t * tx_byte, uint8_t * read_byte)
{
    /* fin: math.unsafe_mode() */
    
    (*read_byte) >>= 1;
    if (hal_IDigIn_read_input(self->_miso))
        (*read_byte) |= 0b10000000;

    hal_IDigOut_set_output_state(self->_mosi, ((*tx_byte) & 0x01) != 0);
    PRIVATE_hal_SpiMasterBitBang__delay(self);
    PRIVATE_hal_SpiMasterBitBang__clock_high(self);
    PRIVATE_hal_SpiMasterBitBang__delay(self);
    PRIVATE_hal_SpiMasterBitBang__clock_low(self);

    (*tx_byte) >>= 1;
}

void hal_SpiMasterBitBang_tx_array(hal_SpiMasterBitBang * self, uint8_t * data, uint8_t data_length)
{
}

void hal_SpiMasterBitBang_tx_byte(hal_SpiMasterBitBang * self, uint8_t tx_byte)
{
}

// virtual table implementation for ISpi. Note that this is extern'd.
const hal_ISpi_vtable hal_ISpi_vtable_imp = {
    .tx_byte = (void (*)(void * self, uint8_t tx_byte))hal_SpiMasterBitBang_tx_byte,
    .rx_byte = (uint8_t (*)(void * self))hal_SpiMasterBitBang_rx_byte,
    .rx_tx_byte = (uint8_t (*)(void * self, uint8_t tx_byte))hal_SpiMasterBitBang_rx_tx_byte,
    .rx_array = (void (*)(void * self, uint8_t * data, uint8_t data_length))hal_SpiMasterBitBang_rx_array,
    .tx_array = (void (*)(void * self, uint8_t * data, uint8_t data_length))hal_SpiMasterBitBang_tx_array,
    .rx_tx_array = (void (*)(void * self, uint8_t * tx_data, uint8_t * rx_data, uint8_t data_length))hal_SpiMasterBitBang_rx_tx_array,
};

