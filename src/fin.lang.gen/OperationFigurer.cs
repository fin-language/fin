namespace fin.lang.gen;

/// <summary>
/// To overcome C# limitations, we have to carefully create operator overloads so that C# compiler doesn't think everything is ambiguous.
/// Related info here: https://github.com/fin-language/fin/issues/12
/// 
/// If in doubt about why a check exists, try removing it and see what happens in autogenerated combination tests.
/// 
/// If we simply defined all possible type combinations, then the C# compiler would think everything is ambiguous.
/// 
/// For example, `my_u8 + 1` would be ambiguous because `1` can be implicitly converted to `u8` or `i8`.
/// To get around that, unsigned numbers define an operator overload that takes an IHasI8 interface instead of an `i8`.
/// `i16 operator +(u8 a, IHasI8 b)`.
/// 
/// Then `my_u8 + 1` will call `u8 operator +(u8 a, u8 b)` because `1` can be implicitly converted to `u8`, but not `IHasI8`.
/// It could convert `1` to `i8` and then to `IHasI8`, but it will only perform a single implicit conversion.
/// 
/// </summary>
public class OperationFigurer
{
    internal static TypeInfo[] types => GenSimNumerics.types;

    public class OperationData
    {
        public TypeInfo classType;
        public TypeInfo otherType;
        public TypeInfo resultType;
        public string otherTypeArgName;
        public string otherValueGetter;

        public OperationData(TypeInfo classType, TypeInfo otherType, string otherTypeArgName, TypeInfo resultType, string otherValueGetter)
        {
            this.classType = classType;
            this.otherType = otherType;
            this.resultType = resultType;
            this.otherTypeArgName = otherTypeArgName;
            this.otherValueGetter = otherValueGetter;
        }
    }

    public static List<OperationData> DetermineTypes(TypeInfo classType, string otherArgName)
    {
        List<OperationData> infos = new();

        // type always support combining with itself.
        infos.Add(new OperationData(classType, classType, classType.fin_name, classType, $"{otherArgName}._csReadValue"));

        AddAllSignedMixing(classType, otherArgName, infos);
        AddAllSameSigned(classType, otherArgName, infos);

        return infos;
    }

    private static void AddAllSameSigned(TypeInfo classType, string otherArgName, List<OperationData> infos)
    {
        foreach (var otherType in types)
            AddSameSigned(classType, otherType, otherArgName, infos);
    }

    private static void AddSameSigned(TypeInfo classType, TypeInfo otherType, string otherArgName, List<OperationData> infos)
    {
        if (classType.is_signed != otherType.is_signed)
            return;

        TypeInfo resultType = classType.GetResultType(otherType);

        // check below might not always be required, but it is actually better to have `u16 + u8` result in implicit promotion of `u8` to `u16`.
        if (classType.CanPromoteTo(otherType))
            infos.Add(new OperationData(classType, otherType, otherType.fin_name, resultType, $"{otherArgName}._csReadValue"));
    }

    private static void AddAllSignedMixing(TypeInfo classType, string otherArgName, List<OperationData> infos)
    {
        foreach (var otherType in types)
            AddSignedMixing(classType, otherType, otherArgName, infos);
    }

    private static void AddSignedMixing(TypeInfo classType, TypeInfo otherType, string otherArgName, List<OperationData> infos)
    {
        // signed numbers rely on unsigned numbers to implicitly convert to larger compatible types for operation.
        // For example: my_i8 + my_u8 will implicitly convert my_u8 to i16 and then perform the operation.
        if (classType.is_signed)
            return;

        // only care about mixing for this part
        if (classType.is_signed == otherType.is_signed)
            return;

        // don't create an operator overload if the types can be implicitly converted to each other.
        // Otherwise, we get ambiguous operator errors.
        // For example, don't create this combination: `i16 operator +(u8 a, IHasI16 b)` as u8 has an implicit conversion to i16 which we need.
        if (classType.CanPromoteToOrViceVersa(otherType))
            return;

        // don't create an operator overload if the result type is too large.
        TypeInfo resultType = classType.GetResultType(otherType);
        if (resultType.width > 64)
            return;
        
        infos.Add(new OperationData(classType, otherType, GenSimNumerics.GenIHasTypeName(otherType), resultType, $"{otherArgName}.value"));
    }
}
